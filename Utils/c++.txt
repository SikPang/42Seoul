* byte
주소를 가질 수 있는 최소 단위
1byte = 8bit = 256가지 상태 = 0~255  or  -128~127  (1bit = 0 or 1)


* 변수
정수형 : char (1byte), short (2byte), int (4byte), long long (8byte)
실수형 : float (4byte), double (8byte)


* 비트에서의 음수, 양수
MSB (Most Significant Bit) : 최상위 부호비트로 1이면 음수, 0이면 양수
양수(10)랑 더해서 0이 나오는 수가 음수(-10)
ex) “0”111 1111 (127)와 더해서 0이 나오는 수 = “1”000 0001 (-127)
ex) “0”000 0001 (1)과 더해서 0이 나오는 수 = “1”111 1111 (-1)


* signed, unsigned
unsigned char = 0~255,  256이 되는 순간 0으로 복귀
signed char = -128~127, 128이 되는 순간 – 붙어서 128, 커질수록 수도 커지며, 255가 -1이 됨


* 실수
부호 비트 + 지수 파트(정수) + 가수 파트(소수점)
float (4byte = 32bit) = 부호 (1bit) + 지수 (8bit) + 가수 (23bit) 
(지수 bit가 커질수록 가수 bit가 줄어듦)
지수 파트는 위의 정수와 동일, 가수 파트는 소수점 자리가 내려갈 때마다 1/2배하여 더함
0.100 = 0.5,  0.010 = 0.25,  0.001 = 0.125,   0.111 = 0.5 + 0.25 + 0.125 = 0.865
고로 == 연산은 피할 것, float보다 double이 정교


* 비트 연산자
<< (left shift) : 비트를 왼쪽으로 밀어서 추가. 2배 4배 8배로 커짐
>> (right shift) : 비트를 오른쪽으로 밀어서 없앰. 1/2배 1/4배 1/8배로 작아지며, 몫만 가져옴
& (비트 곱) : 둘 다 1인 경우 1
| (비트 합) : 둘 중 하나라도 1이면 1
^ (XOR) : 둘이 다르면 1, 같으면 0
~ (반전) : 0은 1로, 1은 0으로


* 비트 연산자 응용
1. 각 상태들을 1, 2, 4, 8, 16 ... 로 define (비트의 각 자리)
1-1. 16진수로 표기하여 커지는 숫자에 더욱 편리하게 
      (0x1, 0x2, 0x4, 0x8,  0x10, 0x20, 0x40, 0x80,  0x100, 0x200, 0x400, 0x800 ...)
2. 비트 합으로 총 상태변수 int에 현재 상태를 추가 (status |= HUNGRY)
3. 총 상태변수와 상태를 곱하여 true 반환 시 현재 그 상태인 것 if
4. 상태의 반전에 총 상태변수와 비트 곱을 하여 상태 제거 (status &= ~HUNGRY)
   (반전하면 현재 상태 비트만 0으로 되어 총 상태변수의 0 은 그대로 0, 
    1은 그대로 1로 내려오며 반전된 상태는 0으로 됨)


* typedef
자료형을 재정의하는 것
C : typedef struct myStruct { int a; int b} mySt; 이후 mySt m; 으로 구현 가능
   or struct myStruct { int a; int b}; 이후 struct myStruct m; 으로 구현 가능
   ( struct끼리 따로 모아두고 거기서 찾아와야 하기 때문)
C++ : struct myStruct { int a; int b}; 이후 myStruct m;으로 구현 가능


*  static과 extern
static은 모든 곳에서의 공통 멤버가 아님, #include가 복사해와서 쓰는 것이기 때문에
각 파일마다 static으로 가져오는 것이며, 각 파일끼리 해당 static 멤버는 공유되지 않음 (다름)
만약, 이를 static 빼고 전역으로 쓸 경우 여러 번 정의했다는 오류가 발생함
extern은 모든 곳에서의 공통 멤버이나, 선언을 한 번 해주고, 초기화도 따로 한 번 해줘야 함


* 헤더 파일 분할 구현 이유
코드 관리 쉬움, 가져다 쓰기 용이함, 코드 재사용 가능


* 포인터
주소를 가져올 때, 해당 주소에 있는 값을 어떤 자료형으로 해석할 것이냐에 따라 값을 보는 관점이 달라짐. float 변수를 int*로 접근 가능하지만, 실수와 정수의 비트 표현기법이 다르기 때문에 다른 값으로 보아 컴파일러가 문법 오류라고 체크해줌. 의도적으로 형변환시, 다른 값 출력. 증감시, 자료형에 따라 다음 자료형 크기만큼의 주소로 이동 (+1시, int일 경우 4byte만큼의 주소 이동)
64bit 환경일 경우 포인터 변수의 크기는 8byte


* 포인터 배열
인덱스로 접근한다는 것이 주소로 접근한다는 뜻
arr[ i ] 는 * ( arr + i ) 를 간단하게 표현한 것
* const와 포인터
1. const int* q= &a;일 때, *q = 100; 안됨. q = &b; 됨.
2. int* const q= &a;일 때, *q = 100; 됨. q = &b; 안됨.
3. const int* const q= &a;일 때, *q = 100; 안됨. q = &b; 안됨.
(const 뒤의 문법을 상수화 시킴, const* 여도 포인터를 상수화)
4. 포인터 매개변수에 const를 선언하여 읽기만 할 수 있는 변수로 활용 가능


* void 포인터
주소로 갔을 때 있는 값에 자료형을 특정하지 않고 모두 받아옴
대신, 역참조 불가(*pVoid), 주소 연산 불가능 (pVoid + 1)


* wchar_t
2byte 문자, “457” 저장 시, 아스키코드로 52, 53, 57, 0 (널문자 포함) 저장 (공백문자도 32에 해당)
char(멀티바이트, 가변길이)는 표준으로 쓰이지 않음, 
호환성과 많은 언어 표현을 위해 wchar(와이드바이트, 2byte, 유니코드(UTF-8))를 쓰는 것이 좋음
2byte로 저장 시 L자를 붙임


* 문자열
char arr[5] = “abcd”; (마지막 널문자 포함)
wchar_t arr[5] = L”abcd”; (어딘가에 있는 문자열을 배열로 옮겨옴)
const wchar_t* wArr = L”abcd”; (어딘가에 있는 문자열의 주소를 다이렉트로 옮김)
wArr[0] = ‘z’; 는 오류, 문자열의 주소를 불러왔을 경우 수정을 하려고 하면 코드 메모리 쪽을 수정하려고 하는 것이기 때문에 막아두는 차원에서 const를 반환값으로 해둠
* 구조체 포인터
MYSTRUCT s = {}; // 생성
MYSTRUCT* st = &s;
(*st).a=100;  or  st->a=100;  or s.a=100;


* 동적할당
int input = 0;
int* pInt = nullptr;

scanf_s(“%d”, &input);
if(input == 100)
	pInt = (int*)malloc(100);	// malloc은 void 포인터, 괄호 안의 숫자만큼 메모리만 할당
if(pInt != nullptr)
	free(pInt):	// 동적할당된 메모리 해제


* 생성자, 소멸자
- 생성자
이니셜라이저를 제공
CMy c : m_i(0), m_f(0.f)
{
}

- 소멸자
프로그램이 종료될 때 (return 0), 스택이 정리될 때 소멸자는 자동으로 실행된다.
1. 생성자와 소멸자를 만들지 않아도 컴파일러가 자동으로 생성해주나 기능이 없음 (기본 생성자, 기본 소멸자)
2. 하나라도 아무 생성자나 소멸자를 구현 시 기본 생성자와 기본 소멸자가 자동으로 생성해주지 않는다.
3. 생성자를 private으로 선언하면 객체를 만들 수 없다.
4. 객체를 생성하면 기본 생성자가 호출됨


* 멤버함수
해당 클래스가 사용하는 전용 함수
(x) CMy::SetInt(10); 	// 해당 클래스의 객체가 필요하므로 안 됨
(O) CMy c;
c.SetInt(10);


* .cpp에서 클래스 내의 함수 분할구현 시
CMy::CMy()
{
}


* this
클래스 내에서 멤버 변수를 호출할 때 this->m_i 로 자기 자신의 주소를 전달하나 생략 가능
바깥에서는 객체.함수()로 호출 함으로써 어느 객체의 주소를 전달할지 정하는 것


* 객체간의 대입 연산자
값 복사


* 참조 변수 (레퍼런스 변수)
변수를 선언할 때, 자료형& 변수 (원본을 참조한다)
Int a = 10;
(1) int* const p = &a;
*p = 100;
(2) int& r = a;
R = 100;
(1)과 (2)가 거의 같음. r은 다른 변수의 포인터를 바꿀 수 없고 값만 바꿀 뿐임
내부적으로는 똑같이 포인터 연산을 진행하나, 
장점으로는 1. 주소 연산 실수 줄임 2. 값을 바꿀 때 역참조 연산을 할 필요가 없음
2번을 통해서 포인터로는 할 수 없는 것들을 가능케함


* operator [] 오버로딩 시 참조 연산자
값을 반환하면 int i = arr[1];  arr[1] = 100;이 불가능
포인터를 반환하면 int* i = arr[1];  *arr[1] = 100;으로 가능
But, 참조 연산자를 반환하면 int i = arr[1];  arr[1] = 100;으로 자연스럽게 구현 가능


* new
c++ 스타일 동적할당
객체를 new로 동적할당 시, 생성자를 자동 호출함


* delete
c++스타일 동적할당 해제
배열 해제시 delete[] 사용


* 템플릿
틀을 만들어서 어느 자료형이던 다 수용하여 유연하게 적용할 수 있게 함
함수나 클래스 선언문 위에 다음과 같은 키워드를 추가 선언
template<typename T>

- 함수 템플릿
template<typename T>
T Add(T a, T b)
{
	return a + b;
}

- 클래스 템플릿
template<typename T>
class CArr
{
private:
	T* data;
public:
	push_back(const T& data);  // 값이 커질 것을 예상해서 복사에 드는 비용을 줄이려 포인터를 가져옴
}

- 클래스 템플릿 구현 함수
클래스 템플릿의 구현 부분은 헤더 파일 안에 존재해야함. cpp에서는 T가 어느 자료형으로 요청되었는지 모르기 때문
함수 하나마다 template 키워드를 작성해주어야 하고, 꺽쇠를 추가하여 해당 타입의 구현본임을 명시
template<typename T>
CArr<T>::CArr()
{
}
- 클래스 템플릿 객체 선언
CArr<float> carr;


* C++ struct는 typedef를 해주지 않더라도 struct라는 키워드를 붙이지 않아도 되지만,
C언어와의 호환성 때문에 써주는게 좋다.


* 템플릿 연결리스트
template<typename T>
struct Node
{
	T		data;
	Node	nextNode;	//  Node<T>로 적어주는게 정석이나 자기 자신 내에서는 써줄 필요 없음
};
template<typename T>
class CList
{
	Node<T>*	head;	// 연쇄적으로 T가 적용되며 이어짐
	int			count;
}


* 구조체도 생성자, 소멸자 구현 가능


* namespace
동일한 이름의 변수명을 사용할 수 있으니까 이름 중복 방지를 위함

- using
using namespace 키워드를 만나면 namespace가 존재하지 않는 것 처럼 취급, 바로 사용 가능
But, 결과적으로 namespace의 기능을 상실함 (namespace들을 많이 using하면 사용 시 모호해짐)
그러므로 using std::cout; 처럼 하나씩 using하여 쓰는게 좋음


* 이너클래스
이너클래스에서 아우터클래스의 private 멤버는 접근이 가능하지만,
아우터클래스에서 이너클래스의 private 멤버는 접근이 불가능
But, 이너클래스에서 아우터클래스를 friend class로 선언하면 아우터클래스에서 접근이 가능


* friend
상대가 friend라고 선언을 해줘야 상대의 private 멤버에 접근이 가능
이너클래스와 아우터클래스 관계 뿐만 아니라 다른 클래스 끼리도 적용 가능
But, 왠만하면 하지 않는 것이 좋음 (private는 원래 접근 불가능하게 할 목적이기 때문, public 멤버 사용 지양과 비슷)


* iterator
list와 vector의 이너클래스, 반복자
end()는 마지막 다음을 가리킴
Container들의 erase 기능에는 공통적으로 인자로 iterator를 전달함

- begin()
template<typename T>
typename CArr<T>::iterator CArr<T>::begin()
{
	iterator iter(m_pData, 0);
	return iter;

	// return iterator(m_pData, 0);		// 임시객체, 객체 이름도 필요 없음
}
typename을 적어준 이유 :  반환 값이 이너클래스일 경우 특정 타입이라는 것을 알려주기 위해 적음

- vector의 begin()
vector는 공간이 부족하면 재할당하기 때문에 처음 대입 받은 iterator가 재할당 이후의 vector 주소와 다름

- erase()
erase 하고 난 iterator는 삭제된 곳을 가리키고 있기 때문에 재사용할 수 없음
erase의 반환 타입이 삭제된 다음 요소의 iterator
결론은 iter = vector.erase(iter); 로 사용해야함


* 후위 연산
iterator operator ++(int)
{
	iterator copy = *this;	// 복사 생성자 호출
	++(*this);				// 오버로딩된 전위 연산자

	return copy;
}


* 복사생성자
CTest t1;
1. CTest t2;
   t2 = t1;
2. CTest t2(t1);
3. CTest t2 = t1;
- 1은 대입 연산자가 적용돼서 복사가 됨, 2, 3은 복사 생성자가 호출됨 (3은 컴파일러가 자동으로 복사생성자로 바꿔줌)


* 이니셜라이저 장점
1. 초기화의 대상을 명확히 인식 가능
2. 선언과 동시에 초기화가 이뤄지기에 성능에 대한 이점
3. 클래스 내의 const 변수를 초기화 가능하다
 - 이니셜라이저는 생성자가 호출되기 이전에 완료되는 특징


* const
1. const 변수를 초기화하지 않고 정의하면 컴파일 오류
2. 클래스 내의 const 변수일 경우 일반적인 방법으로 정의(초기화) 불가능
 - 이니셜라이저 사용
 - const 변수를 static으로 선언하면 정의 가능
3. 클래스 내의 멤버함수 뒤에 const
 - 해당 멤버 함수 내에서 클래스 내의 멤버 변수의 값을 바꿀 수 없음
 - 해당 멤버 함수 내에서 non-const 멤버 함수를 호출할 수 없음 (변수 값 변경할까봐)


* #define과 const의 차이
1. 우선 C가 나온 초기에는 const 개념이 없었고, 추후에 기능을 보완하기 위해 const가 나옴
2. const는 메모리가 할당되고 변수의 type이 정해지므로 에러를 확인하기 쉬움


* list iterator
- insert() 인수로 넘긴 iterator의 좌측에 삽입됨, 새 노드 iterator 반환
- erase() 인수로 넘긴 iterator의 우측 iterator 반환


* inline
- 함수 호출에 대한 비용을 줄여 최적화함
- 매크로 함수처럼 함수를 실제로 호출하지 않고 함수 내용으로 대체되는 기능
- 컴파일러가 적절히 판단하여 inline으로 선언해도 무시될 수 있음
- 코드가 굉장히 짧은데 엄청 자주 호출되는 함수에 적절함 (get,set류)
- 클래스는 헤더에다가 구현하면 inline 처리하겠다는 뜻이 됨 (함수 호출 비용 없애기)


* 템플릿 함수 구현
템플릿이다 보니까 특정 타입을 요청했을 경우 즉시 그런 버전의 클래스가 나와야 해서 헤더에 모든 정보가 있어야 함
- 일반적인 부분은 헤더를 참조하는 만큼 함수가 여러 개가 생겨나서 중복 정의 문제가 남
- 클래스는 헤더에다가 구현하면 inline 처리하겠다는 뜻이 됨 (함수 호출 비용 없애기)
- 결론적으로 템플릿 함수는 모두 헤더에 구현했기에 inline으로 선언이 됨


* tree
1. 그래프의 일종
2. 계층 관계를 표현하기에 용이함
3. 순회가 불가능
- 이진트리 : 자식의 개수가 2개 이하인 형태의 트리
- 완전이진트리 : 루트 노드로부터 항상 자식을 2개씩 채워 나가는 형태의 트리 (힙)
배열 형태로 구현, 현재 인덱스에서 2k+1, 2k+2의 인덱스가 현재 인덱스의 자식
현재 (인덱스-1)/2가 현재 인덱스의 부모 (몫이라 2k+2의 경우 하나 버리게 됨)
- 루트 노드 : 부모가 없는 최상위 노드
- 리프 노드 : 자식이 없는 최하위 노드 (단말 노드)
- 레벨 : 루트 노드로부터 리프 노드까지의 단계
- 높이 : 트리의 가장 높은 레벨


* 트리 순회
1. 전위 순회 (preOrder): 부모 – 왼쪽 자식 – 오른쪽 자식
2. 중위 순회 (inOrder) : 왼쪽 자식 – 부모 – 오른쪽 자식
3. 후위 순회 (postOrder) : 왼쪽 자식 – 오른쪽 자식 – 부모
- 모든 트리 탐색의 시작은 루트부터
- 전, 중, 후의 기준은 부모의 위치


* 이진탐색 (트리)
1. 데이터가 정렬되어 있어야 함
2. 중간으로 접근하여 어디로 갈지 결정, O(logn)
3. 이진탐색트리 (BST)
- 처음 루트가 정해지고, 루트보다 작으면 왼쪽 자식, 크면 오른쪽 자식으로 재귀적으로 들어감
- 데이터가 입력될 때 정렬된 형태로 저장하기 위해 약간의 손해를 감수함
- 중위 순회로 정렬된 순서대로 순회 가능
- But, 입력값이 오름차순일 경우 최악의 경우가 생김 -> 자가균형 이진탐색트리 (레드블랙트리)


* set
: 이진탐색트리
데이터가 insert 될 때마다 동적 할당되어 힙 메모리에 저장됨


* map
: 레드블랙 이진탐색트리
- 키 값에 읽기전용메모리(“hey”)를 넣으면 포인터 자체를 비교하기 때문에 지양


* string
: char*는 주소값이지만, string은 값을 대입연산자(오버로딩된)로 받으면 자체적으로 가지고 있는 공간에 복사를 받음, 따라서 인덱스로도 접근 및 수정이 가능
비교연산자(오버로딩된)로 문자열 간의 우위를 알아볼 수 있음


* enum
#define은 전처리기라서 컴파일 이전에 바로 값으로 대체가 되어버린다.
하지만 enum은 타입이 명시되어 있어서 디버깅 하기가 수월하다.
하지만 #define은 전처리기라서 사용처가 다양하다 (매크로함수 등)
enum MY_TYPE
{
	Type1,		// 0
	Type2,		// 1
	Type3 = 100,	// 100
	Type4		// 101
};
int a = Type1;

- enum class : 서로 다른 enum에서 중복된 이름이 나올 경우 모호해져서 사용할 수 없는 문제 해결
enum class MY_TYPE2
{
	Type		// 0
};
int a = (int) MY_TYPE2 :: Type;


* 객체지향 언어 특징
1. 캡슐화 : 멤버 변수, 멤버 함수를 한 곳에 모아 객체화해서 구현 + 은닉성
2. 상속 
3. 다형성
4. 추상화


* 상속
class Parent
{
private:
	int m;
public:
	Parent(int i)
	 : m(i)
	{
	}
}

class Child : public Parent
{
private:
	int n;
public:
	Child(int i)
	 : Parent(i)	// 오버로딩된 생성자가 필요하다면 이렇게 자식 클래스의 생성자에서 명시를 해줘야함
	 , n(0)
	{
	}
}

1. 부모 클래스의 기능을 다 받고 추가적으로 구현하는 용도
2. 똑같은 기능을 여러번 구현할 필요가 없음 -> 코드의 재사용성 상승
3. 자식 객체 생성 시, 부모 클래스의 총 용량과 자식 클래스의 총 용량이 같이 할당됨 (순서대로)
4. 자식 객체 생성 시, 부모 클래스의 생성자와 자식 클래스의 생성자가 같이 실행됨 
   생성자는 자식 클래스가 먼저 호출되나, 실행 전에 스택이 계속 쌓이면서 부모의 생성자가 먼저 실행됨
   자식 클래스의 이니셜라이저에서 부모 클래스의 멤버 초기화 불가능
5. 부모 클래스의 private 멤버는 자식 클래스에서 접근 불가 (protected : 자식 클래스까지만 접근 가능)
6. 자식 클래스에서는 부모 클래스의 멤버를 그냥 자신의 멤버처럼 이름만으로 호출 가능
7. 부모 클래스의 public 멤버는 자식 클래스의 이름으로 호출 가능
8. 소멸자는 자식 클래스부터 호출, 실행됨 (함수 스택은 쌓임)


* 오버라이딩
부모 클래스의 멤버함수를 자식 클래스에서 재정의, 추후 자식 클래스에 구현된 기능이 호출 (상속 관계에서만 가능)
child.Parent::Output(); 으로 오버라이딩 안 된 부모의 Output 함수가 호출됨


* 다형성
하나의 타입(Parent*)으로 다양한 형태일 수도 있는 성질을 나타낼 수 있음
Parent* parent = &child;		// 업캐스팅
 // 용량과는 상관 없이 child 객체도 parent 주소가 먼저 생기기 때문에 문법은 문제 없음
 // 하지만 child의 오버라이딩을 무시함 (virtual로 해결 가능)
Child* child = &parent;
 // child 주소가 와야하는데 parent 주소가 와서 오류

- virtual
위의 문제를 해결하기 위해 virtual 키워드를 추가하여 가상함수로 만들고 클래스 정보에 해당 함수를 등록함,
각 객체들은 만들어질 때 각자 자기가 해당되는 정보를 등록해두기 때문에 그 정보를 보고 호출함


* 다운캐스팅
virtual로 해결되는 것은 오버라이딩, 자식에서 새로운 함수를 만들었을 경우 virtual로 해결이 안 됨
일시적으로 자식 클래스 타입으로 캐스팅을 하는 것
우리가 해당 포인터가 자식 객체라는 것을 알면 상관 없지만, 알 수 없을 때는 위험함
따라서 강제 형변환 말고, dynamic_cast라는 것을 이용해서 안전하게 캐스팅 할 수 있음 (RTTI)
dynamic_cast가 실패했을 때는 nullptr이 반환되어 조건문으로 대비 가능


* 업캐스팅
Parent* parent = &child;	// 다형성을 이용하여 코드의 재사용성을 높이기 위함


* malloc과 new의 차이
1. malloc은 라이브러리 제공 함수로, stdlib.h 을 include 해주어야 사용 가능하지만, 
   new는 기본으로 제공하는 키워드이므로 별도의 라이브러리 추가 없이 바로 사용 가능
2. malloc은 사이즈를 매개변수로 받고, 리턴 타입이 void*형이므로 sizeof()와 캐스팅을 활용해야 함
   반면에 new는 할당할 타입을 지정하면 알아서 할당할 타입의 포인터로 넘어오기 때문에 
   할당할 타입과 같은 타입의 포인터 변수로 받아오기만 하면 됨
3. malloc은 메모리를 동적으로 할당하는 것만이 목적이기 때문에 초기값을 지정해줄 수 없지만, 
   new는 할당과 동시에 초기화가 가능
4. 객체를 new 할 경우 new는 생성자를 자동으로 호출합니다. 

차이점만 본다면 malloc을 쓸 이유가 없어보이지만 malloc이 필요한 경우도 분명히 존재합니다. 
malloc의 경우, realloc이라는 함수로 재할당이 가능하지만, 
new에는 이에 대응하는 것이 없기때문에 새로 할당 -> 복사 -> 해제 하는 과정을 거쳐야합니다. 
하지만 객체의 경우 반드시 new / delete 를 사용해서 할당 / 해제 해주어야합니다. 
객체가 아닌 경우에 재할당이 빈번하게 일어난다면, malloc / free 가 더 좋은 선택이 될 수 있습니다.
